snippet test "testcase" b
int test;
cin >> test;

while(test--){
	$1
}
endsnippet

snippet List "Description" b
struct ListNode {
	int val;
	ListNode *next;
	ListNode() : val(0), next(nullptr) {}
	ListNode(int x) : val(x), next(nullptr) {}
	ListNode(int x, ListNode *next) : val(x), next(next) {}
};
endsnippet

snippet powbin "Binary Exponentiation under Modulo" b
${4:int} binpow(${1:T} ${2:first_num},$1 ${3:power_level}){
	$1 res = 1;
	while($3){
		if($3&1) ( res*=$2 )%=hell;
		( $2 *= $2 )%=hell;
		$3 = $3/2;
	}
	return res;
}
endsnippet

snippet karo "main template" b
#include <bits/stdc++.h>
#define int long long
#define all(a) (a).begin(),(a).end()
using namespace std;
#define sim template < class c
#define ris return * this
#define dor > debug & operator <<
#define eni(x) sim > typename \
  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {
sim > struct rge { c b, e; };
sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }
sim > auto dud(c* x) -> decltype(cerr << *x, 0);
sim > char dud(...);
struct debug {
#ifdef LOCAL
~debug() { cerr << endl; }
eni(!=) cerr << boolalpha << i; ris; }
eni(==) ris << range(begin(i), end(i)); }
sim, class b dor(pair < b, c > d) {
  ris << "(" << d.first << ", " << d.second << ")";
}
sim dor(rge<c> d) {
  *this << "[";
  for (auto it = d.b; it != d.e; ++it)
    *this << ", " + 2 * (it == d.b) << *it;
  ris << "]";
}
#else
sim dor(const c&) { ris; }
#endif
};
#define imie(...) " [" << #__VA_ARGS__ ": " << (__VA_ARGS__) << "] "

signed main(){
	ios_base::sync_with_stdio(false);

	$1

	return 0;
}
endsnippet

snippet leetcode "LeetCode snippets" b
#include <bits/stdc++.h>
using namespace std;

$1

int main(){
	return 0;
}
endsnippet

snippet kmp "kmp algorithm" b
vector<int>prefix_function(string s){
	int n = (int)s.size();
	vector<int>pi(n,0);
	for(int i=1;i<n;i++){
	int j = pi[i-1];
	while(j > 0 && s[i] != s[j]){
		j = pi[j-1];
		}
		if(s[i] == s[j])
			j++;
		pi[i] = j;
	}
	return pi;
}

bool knutt_moris(string pattern,string target){
	int n = (int)pattern.size();
	int m = (int)target.size();

	vector<int>pi = prefix_function(pattern);

	int i = 0;
	int k = 0;
	while(i<n){
		if(target[i] == pattern[k]){
			i++;
			k++;
		}else{
			if(k != 0) k = pi[k-1];
			else i++;
		}
		if(k == m) return true;
	}
	return false;
}
endsnippet

# Debuging template
snippet warshaw "Errichto Debuging template" b
#define sim template < class c
#define ris return * this
#define dor > debug & operator <<
#define eni(x) sim > typename \
  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {
sim > struct rge { c b, e; };
sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }
sim > auto dud(c* x) -> decltype(cerr << *x, 0);
sim > char dud(...);
struct debug {
#ifdef LOCAL
~debug() { cerr << endl; }
eni(!=) cerr << boolalpha << i; ris; }
eni(==) ris << range(begin(i), end(i)); }
sim, class b dor(pair < b, c > d) {
  ris << "(" << d.first << ", " << d.second << ")";
}
sim dor(rge<c> d) {
  *this << "[";
  for (auto it = d.b; it != d.e; ++it)
    *this << ", " + 2 * (it == d.b) << *it;
  ris << "]";
}
#else
sim dor(const c&) { ris; }
#endif
};
#define imie(...) " [" << #__VA_ARGS__ ": " << (__VA_ARGS__) << "] "
endsnippet

snippet graph_bfs "BFS" b
queue<${1:Type}> q;
vector<$1>visited(${2:size},false);
vector<$1>dist($2,0),parent($2,0);

q.push(${3:starting_index});
visited[$3] = true;
parent[$3] = -1;

while(q.empty() == false){
	auto p = q.front();
	q.pop();
	for(int u:adj[p]){
		if(!visited[u]){
			q.push(u);
			visited[u] = true;
			dist[u] = dist[p] + 1;
			parent[u] = p;
		}
	}
}
endsnippet

snippet graph_dfs "dfs" b
${1:void} dfs(${2:int} cur,$2 parent){
	for($2 child : $3{})
}
endsnippet
